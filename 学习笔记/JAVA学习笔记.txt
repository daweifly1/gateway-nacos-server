1.线程池

 public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
	
public static ExecutorService newWorkStealingPool(int parallelism) {
        return new ForkJoinPool
            (parallelism,
             ForkJoinPool.defaultForkJoinWorkerThreadFactory,
             null, true);
    }
	
newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中


public static ExecutorService newSingleThreadExecutor() {
	return new FinalizableDelegatedExecutorService
		(new ThreadPoolExecutor(1, 1,
								0L, TimeUnit.MILLISECONDS,
								new LinkedBlockingQueue<Runnable>()));
}

public static ExecutorService newCachedThreadPool() {
	return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
								  60L, TimeUnit.SECONDS,
								  new SynchronousQueue<Runnable>());
}


SynchronousQueue是无界的，是一种无缓冲的等待队列，但是由于该Queue本身的特性，在某次添加元素后必须等待其他线程取走后才能继续添加；可以认为SynchronousQueue是一个缓存值为1的阻塞队列，但是 isEmpty()方法永远返回是true，remainingCapacity() 方法永远返回是0，remove()和removeAll() 方法永远返回是false，iterator()方法永远返回空，peek()方法永远返回null。


LinkedBlockingQueue是无界的，是一个无界缓存的等待队列。
基于链表的阻塞队列，内部维持着一个数据缓冲队列（该队列由链表构成）。当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。
LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。


ArrayBlockingQueue是有界的，是一个有界缓存的等待队列。
基于数组的阻塞队列，同LinkedBlockingQueue类似，内部维持着一个定长数据缓冲队列（该队列由数组构成）。ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。
ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。
ArrayBlockingQueue和LinkedBlockingQueue是两个最普通、最常用的阻塞队列，一般情况下，处理多线程间的生产者消费者问题，使用这两个类足以。



public static ScheduledExecutorService newSingleThreadScheduledExecutor() {
	return new DelegatedScheduledExecutorService
		(new ScheduledThreadPoolExecutor(1));
}



public static ExecutorService unconfigurableExecutorService(ExecutorService executor) {
	if (executor == null)
		throw new NullPointerException();
	return new DelegatedExecutorService(executor);
}



2.Object 的 hashcode 方法重写了，equals 方法要不要改？

不需要，但是equals改了 hashcode一定要修改


3.SQL 优化的常见方法有哪些

	1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
	2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
	3.应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描
	4.应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描
	5.in 和 not in 也要慎用，否则会导致全表扫描，如：	
	select id from t where num in(1,2,3)	
	对于连续的数值，能用 between 就不要用 in 了：	
	select id from t where num between 1 and 3	
		
	6.下面的查询也将导致全表扫描：	
	select id from t where name like '%abc%'	
		
	7.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：	
	select id from t where num/2=100	
	应改为:	
	select id from t where num=100*2	
		
	8.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：	
	select id from t where substring(name,1,3)='abc'--name以abc开头的id	
	应改为:	
	select id from t where name like 'abc%'	
		
	9.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。	
		
	10.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，	
	否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。	
		
	11.不要写一些没有意义的查询，如需要生成一个空表结构：	
	select col1,col2 into #t from t where 1=0	
	这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：	
	create table #t(...)	
		
	12.很多时候用 exists 代替 in 是一个好的选择：	
	select num from a where num in(select num from b)	
	用下面的语句替换：	
	select num from a where exists(select 1 from b where num=a.num)	
		
	13.并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，	
	如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。	
		
	14.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，	
	因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。	
	一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。	
		
	15.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。	
	这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。	
		
	16.尽可能的使用 varchar 代替 char ，因为首先变长字段存储空间小，可以节省存储空间，	
	其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。	
		
	17.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。	
		
	18.避免频繁创建和删除临时表，以减少系统表资源的消耗。
	
	19.临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。	
	
	20.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，	
	以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。

	21.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。	
		
	22.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。	
		
	23.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。

	24.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。
	在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。
	25.尽量避免大事务操作，提高系统并发能力。26.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 
	

4.项目中的监控：那个监控指标常见的有哪些

性能测试需要使用不同的工具，结合系统日志，监控服务器、应用等方面的多项指标。以下阐述监控指标、监控工具、瓶颈分析。

服务端监控指标
性能测试通常需要监控的指标包括：

服务器 Linux（包括CPU、Memory、Load、I/O）。

数据库：Mysql（缓存命中、索引、单条SQL性能、数据库线程数、数据池连接数）。

中间件：1.tomcat 2、nginx   3、memcache（包括线程数、连接数、日志）。

网络： 吞吐量、吞吐率。

应用： jvm内存、日志、Full GC频率。

客户端监控指标
LoadRunner：用户执行情况、场景状态、事务响应时间、TPS、吞吐量等。

测试机资源：CPU、Memory、网络、磁盘空间。

常用监控工具
Jstat

监控java 进程GC情况，判断GC是否正常。

JConsole

监控java内存、javaCPU使用率、线程执行情况等，需要在JVM参数中进行配置。

JMap

监控java程序是否有内存泄漏，需要配合eclipse插件或者MemoryAnalyzer来使用。

JProfiler

全面监控每个节点的CPU使用率、内存使用率、响应时间累计值、线程执行情况等，需要在JVM参数中进行配置。

Nmon

全面监控linux系统资源使用情况，包括CPU、内存、I/O等，可独立于应用监控。

Probe

全面监控tomcat的线程、内存、JVM CPU 使用率、OS 和 JVM内存使用率、交换区使用率、每30秒内接收到的请求数目等等

Memadim

1.   服务器参数监控：STATS、SETTINGS、ITEMS、SLABS、SIZES实时刷新

2.  服务器性能监控：GET、DELETE、INCR、DECR、CAS等常用操作命中率实时监控

3.  支持数据遍历，方便对存储内容进行监视

4.  支持条件查询，筛选出满足条件的KEY或VALUE

性能分析
分析信息来源

5.  监控工具所采集的信息。包括TPS、响应时间、用户并发数、JVM内存、Full GC频率、tomcat连接数，数据sql执行时间、memcache的命中率、nginx的连接数等。

6.  应用服务器的日志。包括错误日志、超时日志等。

7.  项目配合人员所提供的信息。包括DBA提供的数据库监控信息、开发人员提供的代码逻辑信息。

分析标准

1.通过性能指标的表现形式，分析性能是否稳定。比如：

2.响应时间是否符合性能预期，表现是否稳定。

3.应用日志中，超时的概率，是否在可接受的范围之内。

8.  TPS维持在多大的范围内，是否有波形出现，标准差有多少，是否符合预期。

9.  服务器CPU、内存、load是否在合理的范围内，等等。

分析工具

对于部分性能指标，可借助自动分析工具，统计出数据的总体趋势：

1、LoadRunner analysis 分析

LoadRunneranalysis是loadrunner的一个部件，用于将运行过程中所采集到的数据生成报表，主要用于采集TPS、响应时间、吞吐量、服务器资源使用情况等变化趋势。

2、Memory Analyzer分析

Memory Analyzer工具可以解析Jmap dump出来的内存信息，查找是否有内存泄漏。

3、nmon_analyser分析

nmon工具可以采集服务器的资源信息。列出CPU、MEM、网络、I/O等资源指标的使用情况。

4、MONyog分析

通过此工具我们能够跟踪到执行比较慢的sql语句，并且可以分析出sql语句执行时扫描的行数，使用的索引情况。




